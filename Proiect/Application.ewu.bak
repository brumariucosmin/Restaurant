$version 12.05

// This is the root component of the entire GUI application.
$rect <70,140,270,180>
$output false
class Application : Core::Root
{
  $rect <500,10,700,50>
  inherited property Bounds = <0,0,272,480>;

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <570,130,790,460>;
  }

  $rect <20,20,160,60>
  object Application::DesertMenu DesertMenu
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::DrinksMenu DrinksMenu
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::MMenu MMenu
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::SoupMenu SoupMenu
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::Screen Screen
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::WelcomeScreen WelcomeScreen
  {
    preset Bounds = <0,0,272,480>;
  }
}

// Componente&Clase
note group Note2
{
  attr Bounds = <50,110,290,540>;
}

// Resurse
note group Note3
{
  attr Bounds = <320,110,560,570>;
}

// Configurati obiecte
note group Note4
{
  attr Bounds = <610,110,870,430>;
}

$rect <340,150,540,190>
$output false
resource Resources::Bitmap mainScreen
{
  attr bitmapfile FileName = .\Menu restaurant1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <70,240,270,280>
$output false
class Screen : Core::Group
{
  $rect <560,340,760,380>
  inherited property Bounds = <0,0,272,480>;

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <490,0,900,300>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,272,480>;
    preset Bitmap = Application::mainScreen;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SoupTouchHandler
  {
    preset Point4 = <11,109>;
    preset Point3 = <126,109>;
    preset Point2 = <126,209>;
    preset Point1 = <11,209>;
    preset OnPress = onAnimateSoupMenu;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler DrinksTouchHandler
  {
    preset Point4 = <136,87>;
    preset Point3 = <250,87>;
    preset Point2 = <250,191>;
    preset Point1 = <136,191>;
    preset OnPress = onAnimateDrinksMenu;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler MenuTouchHandler
  {
    preset Point4 = <11,271>;
    preset Point3 = <126,271>;
    preset Point2 = <126,371>;
    preset Point1 = <11,371>;
    preset OnPress = onAnimateMmenu;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler DesertTouchHandler
  {
    preset Point4 = <136,262>;
    preset Point3 = <250,262>;
    preset Point2 = <250,362>;
    preset Point1 = <136,362>;
    preset OnPress = onAnimateDesertMenu;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton1
  {
    preset Bounds = <83,415,190,480>;
    preset Bitmap = Application::BuyButton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler2
  {
    preset Point4 = <83,430>;
    preset Point3 = <190,430>;
    preset Point2 = <190,463>;
    preset Point1 = <83,463>;
    preset OnPress = onAnimateBuyScreen;
  }

  // This is a slot method.
  $rect <310,440,510,480>
  slot onAnimateBuyScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect.Enabled = true;
    //this.Bounds = RectEffect.Value;
    RectEffect.Reversed = true;
    BuyScreen.Bounds = RectEffect.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <310,400,510,440>
  object Effects::RectEffect RectEffect
  {
    preset OnAnimate = onAnimateBuyScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::BuyScreen BuyScreen
  {
    preset Bounds = <53,-602,325,-122>;
  }

  $rect <20,20,160,60>
  object Application::DesertMenu DesertMenu
  {
    preset Bounds = <325,-602,597,-122>;
  }

  $rect <20,20,160,60>
  object Application::DrinksMenu DrinksMenu
  {
    preset Bounds = <550,-725,822,-245>;
  }

  $rect <20,20,160,60>
  object Application::MMenu MMenu
  {
    preset Bounds = <683,-654,955,-174>;
  }

  $rect <20,20,160,60>
  object Application::SoupMenu SoupMenu
  {
    preset Bounds = <521,-600,793,-120>;
  }

  // This is a slot method.
  $rect <510,440,710,480>
  slot onAnimateDesertMenu
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect1.Enabled = true;
    //this.Bounds = RectEffect1.Value;
    RectEffect1.Reversed = true;
    DesertMenu.Bounds = RectEffect1.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <510,400,710,440>
  object Effects::RectEffect RectEffect1
  {
    preset OnAnimate = onAnimateDesertMenu;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // This is a slot method.
  $rect <310,520,510,560>
  slot onAnimateDrinksMenu
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect2.Enabled = true;
    //this.Bounds = RectEffect2.Value;
    RectEffect2.Reversed = true;
    DrinksMenu.Bounds = RectEffect2.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <310,480,510,520>
  object Effects::RectEffect RectEffect2
  {
    preset OnAnimate = onAnimateDrinksMenu;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // This is a slot method.
  $rect <510,520,710,560>
  slot onAnimateMmenu
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect3.Enabled = true;
    //this.Bounds = RectEffect3.Value;
    RectEffect3.Reversed = true;
    MMenu.Bounds = RectEffect3.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <510,480,710,520>
  object Effects::RectEffect RectEffect3
  {
    preset OnAnimate = onAnimateMmenu;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // This is a slot method.
  $rect <410,600,610,640>
  slot onAnimateSoupMenu
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect4.Enabled = true;
    //this.Bounds = RectEffect4.Value;
    RectEffect4.Reversed = true;
    SoupMenu.Bounds = RectEffect4.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <410,560,610,600>
  object Effects::RectEffect RectEffect4
  {
    preset OnAnimate = onAnimateSoupMenu;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Image
  $member Note
  $member SoupTouchHandler
  $member DrinksTouchHandler
  $member MenuTouchHandler
  $member DesertTouchHandler
  $member returnButton1
  $member SimpleTouchHandler2
  $member onAnimateBuyScreen
  $member RectEffect
  $member BuyScreen
  $member DesertMenu
  $member DrinksMenu
  $member MMenu
  $member SoupMenu
  $member onAnimateDesertMenu
  $member RectEffect1
  $member onAnimateDrinksMenu
  $member RectEffect2
  $member onAnimateMmenu
  $member RectEffect3
  $member onAnimateSoupMenu
  $member RectEffect4
}

$rect <70,190,270,230>
$output false
class WelcomeScreen : Core::Group
{
  $rect <290,90,490,130>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,272,480>;
    preset Bitmap = Application::BackgroundWelcomeScreen;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <272,0>;
    preset Point2 = <272,480>;
    preset Point1 = <0,480>;
    preset OnPress = onAnimate;
  }

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <510,-30,730,170>;
  }

  // This is a slot method.
  $rect <360,220,560,260>
  slot onAnimate
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect.Enabled = true;
    this.Bounds = RectEffect.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <360,180,560,220>
  object Effects::RectEffect RectEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }
}

$rect <340,199,540,239>
$output false
resource Resources::Bitmap Soup
{
  attr bitmapfile FileName = .\Meniu supe.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,249,540,289>
$output false
resource Resources::Bitmap Desert
{
  attr bitmapfile FileName = .\Desert.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,299,540,339>
$output false
resource Resources::Bitmap Drinks
{
  attr bitmapfile FileName = .\bauturi.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,349,540,389>
$output false
resource Resources::Bitmap Menu
{
  attr bitmapfile FileName = .\Menu principal.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,398,540,438>
$output false
resource Resources::Bitmap BuyButton
{
  attr bitmapfile FileName = .\shop (1).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,449,540,489>
$output false
resource Resources::Bitmap BackgroundWelcomeScreen
{
  attr bitmapfile FileName = .\poza_menu_background.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <70,290,270,330>
$output false
class SoupMenu : Core::Group
{
  $rect <520,230,720,270>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Views::Image Soup
  {
    preset Bounds = <0,0,272,480>;
    preset Bitmap = Application::Soup;
  }

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <500,10,730,210>;
  }

  // Buy Menu
  note group Note1
  {
    attr Bounds = <410,300,850,500>;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton
  {
    preset Bounds = <0,426,136,480>;
    preset Bitmap = Application::returnbutton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler BuyTouchHandler
  {
    preset Point4 = <153,438>;
    preset Point3 = <256,438>;
    preset Point2 = <256,470>;
    preset Point1 = <153,470>;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton1
  {
    preset Bounds = <136,426,272,480>;
    preset Bitmap = Application::BuyButton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler ReturnTouchHandler
  {
    preset Point4 = <16,438>;
    preset Point3 = <121,438>;
    preset Point2 = <121,470>;
    preset Point1 = <16,470>;
    preset OnPress = onAnimateScreen;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SoupNo1TouchHandler
  {
    preset Point4 = <0,98>;
    preset Point3 = <136,98>;
    preset Point2 = <136,262>;
    preset Point1 = <0,262>;
    preset OnPress = onTap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SoupNo2TouchHandler
  {
    preset Point4 = <136,98>;
    preset Point3 = <272,98>;
    preset Point2 = <272,262>;
    preset Point1 = <136,262>;
    preset OnPress = onTap1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SoupNo3TouchHandler
  {
    preset Point4 = <0,262>;
    preset Point3 = <136,262>;
    preset Point2 = <136,426>;
    preset Point1 = <0,426>;
    preset OnPress = onTap2;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SoupNo4TouchHandler
  {
    preset Point4 = <136,262>;
    preset Point3 = <272,262>;
    preset Point2 = <272,426>;
    preset Point1 = <136,426>;
    preset OnRelease = onTap;
    preset OnPress = onTap3;
  }

  // This is a slot method.
  $rect <630,340,830,380>
  slot onTap
  {
    if ( SoupNo1TouchHandler.Inside )
    {
        TapNo = TapNo + 1;
         trace "tapuri", TapNo;
       
    }


  }

  $rect <420,340,620,380>
  var int32 TapNo = 0;

  // This is a slot method.
  $rect <530,560,730,600>
  slot onAnimateScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect1.Enabled = true;
    this.Bounds = RectEffect1.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <530,520,730,560>
  object Effects::RectEffect RectEffect1
  {
    preset OnAnimate = onAnimateScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // This is a slot method.
  $rect <630,380,830,420>
  slot onTap1
  {
    if ( SoupNo2TouchHandler.Inside )
    {
        TapNo1 = TapNo1 + 1;
         trace "tapuri", TapNo1;
       
    }


  }

  $rect <420,380,620,420>
  var int32 TapNo1 = 0;

  // This is a slot method.
  $rect <630,420,830,460>
  slot onTap2
  {
    if ( SoupNo3TouchHandler.Inside )
    {
        TapNo2 = TapNo2 + 1;
         trace "tapuri", TapNo2;
       
    }


  }

  $rect <420,420,620,460>
  var int32 TapNo2 = 0;

  // This is a slot method.
  $rect <630,460,830,500>
  slot onTap3
  {
    if ( SoupNo4TouchHandler.Inside )
    {
        TapNo3 = TapNo3 + 1;
         trace "tapuri", TapNo3;
       
    }


  }

  $rect <420,460,620,500>
  var int32 TapNo3 = 0;
}

$rect <70,340,270,380>
$output false
class BuyScreen : Core::Group
{
  $rect <480,290,680,330>
  inherited property Bounds = <0,0,272,480>;

  $rect <520,80,720,120>
  slot Press
  {
    postsignal OnPress;
  }

  $rect <519,39,719,79>
  property slot OnPress = null;

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <510,0,730,200>;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <160,600,350,640>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var Application::SoupMenu soup;
    var int32 itemNo = VerticalList.Item;

    var Application::BuyScreenElement itemView = (Application::BuyScreenElement)VerticalList.View;

    if ( itemView == null )
      return;
      

    itemView.Price = Your_DataBase_Item_Price[itemNo];

                         
    itemView.Bounds.size = VerticalList.ViewSize;

  }

  // Simple storage for the item data
  note group Note2
  {
    attr Bounds = <440,370,750,590>;
  }

  $rect <160,520,360,560>
  slot OnQueryItemClass
  {
    // Get the number of the item to query its class.
    var int32 itemNo = VerticalList.Item;

    // Estimate the class of the item and store it in the list.
    VerticalList.QueriedItemClass = Your_DataBase_Item_Class[ itemNo ];
  }

  $rect <160,560,360,600>
  slot OnQueryItemHeight
  {
    // Get the number of the item to query its class.
    var int32 itemNo = VerticalList.Item;

    // Estimate the height  of the item and store it in the list.
    VerticalList.QueriedItemHeight = Your_DataBase_Item_Height[ itemNo ];
  }

  $rect <460,420,730,460>
  array class Your_DataBase_Item_Class[ 16 ] =
  (
    Default[0] = Application::BuyScreenElement;
    Default[1] = Application::BuyScreenElement;
    Default[2] = Application::BuyScreenElement;
    Default[3] = Application::BuyScreenElement;
    Default[4] = Application::BuyScreenElement;
    Default[5] = Application::BuyScreenElement;
    Default[6] = Application::BuyScreenElement;
    Default[7] = Application::BuyScreenElement;
    Default[8] = Application::BuyScreenElement;
    Default[9] = Application::BuyScreenElement;
    Default[10] = Application::BuyScreenElement;
    Default[11] = Application::BuyScreenElement;
    Default[12] = Application::BuyScreenElement;
    Default[13] = Application::BuyScreenElement;
    Default[14] = Application::BuyScreenElement;
    Default[15] = Application::BuyScreenElement;
  );

  $rect <460,460,730,500>
  array int32 Your_DataBase_Item_Height[ 16 ] =
  (
    Default[0] = 100;
    Default[1] = 100;
    Default[2] = 100;
    Default[3] = 100;
    Default[4] = 100;
    Default[5] = 100;
    Default[6] = 100;
    Default[7] = 100;
    Default[8] = 100;
    Default[9] = 100;
    Default[10] = 100;
    Default[11] = 100;
    Default[12] = 100;
    Default[13] = 100;
    Default[14] = 100;
    Default[15] = 100;
  );

  $rect <460,500,730,540>
  array Resources::Bitmap Your_DataBase_Item_Title[ 16 ] =
  (
    Default[0] = Application::Soup1;
    Default[1] = Application::Soup2;
    Default[2] = Application::Soup3;
    Default[3] = Application::Soup4;
    Default[4] = Application::Desert1;
    Default[5] = Application::Desert2;
    Default[6] = Application::Desert3;
    Default[7] = Application::Desert4;
    Default[8] = Application::Drinks1;
    Default[9] = Application::Drinks2;
    Default[10] = Application::Drinks3;
    Default[11] = Application::Drinks4;
    Default[12] = Application::Menu1;
    Default[13] = Application::Menu2;
    Default[14] = Application::Menu3;
    Default[15] = Application::Menu4;
  );

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,272,400>;
    preset OnQueryItemClass = OnQueryItemClass;
    preset OnQueryItemHeight = OnQueryItemHeight;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset NoOfItems = 16;
  }

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,275,485>;
    preset SlideHorz = true;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <2,427,137,485>;
    preset Bitmap = Application::confirm;
  }

  $rect <20,20,160,60>
  object Views::Image background
  {
    preset Bounds = <0,-4,275,485>;
    preset Bitmap = Application::Bitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,438>;
    preset Point3 = <136,438>;
    preset Point2 = <136,471>;
    preset Point1 = <0,471>;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <151,427,272,480>;
    preset Bitmap = Application::returnbutton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <160,438>;
    preset Point3 = <272,438>;
    preset Point2 = <272,471>;
    preset Point1 = <160,471>;
    preset OnPress = onAnimateScreen;
  }

  $rect <460,540,730,580>
  array string Your_DataBase_Item_Price[ 16 ] =
  (
    Default[0] = 20;
    Default[1] = 20;
    Default[2] = 20;
    Default[3] = 20;
    Default[4] = 20;
    Default[5] = 20;
    Default[6] = 20;
    Default[7] = 20;
    Default[8] = 20;
    Default[9] = 20;
    Default[10] = 20;
    Default[11] = 20;
    Default[12] = 20;
    Default[13] = 20;
    Default[14] = 20;
    Default[15] = 20;
  );

  // This is a slot method.
  $rect <490,690,690,730>
  slot onAnimateScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect1.Enabled = true;
    this.Bounds = RectEffect1.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <490,650,690,690>
  object Effects::RectEffect RectEffect1
  {
    preset OnAnimate = onAnimateScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::SoupMenu SoupMenu
  {
    preset Bounds = <364,-427,636,53>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member background
  $member Press
  $member OnPress
  $member Note
  $member OnLoadItem
  $member Note2
  $member OnQueryItemClass
  $member SlideTouchHandler
  $member OnQueryItemHeight
  $member Your_DataBase_Item_Class
  $member Your_DataBase_Item_Height
  $member Your_DataBase_Item_Title
  $member VerticalList
  $member Image
  $member SimpleTouchHandler
  $member Image1
  $member SimpleTouchHandler1
  $member Your_DataBase_Item_Price
  $member onAnimateScreen
  $member RectEffect1
  $member SoupMenu
}

$rect <70,390,270,430>
$output false
class DrinksMenu : Core::Group
{
  $rect <360,290,560,330>
  inherited property Bounds = <0,0,272,480>;

  $rect <360,390,560,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <360,350,560,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,272,480>;
    preset Bitmap = Application::Drinks;
  }

  $rect <510,60,710,100>
  slot onMenu1
  {
    postsignal onShow;
  }

  $rect <510,20,710,60>
  property slot onShow = null;

  $rect <510,140,710,180>
  slot onBuyScreen
  {
    postsignal onShow2;
  }

  $rect <510,100,710,140>
  property slot onShow2 = null;

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <500,-10,730,190>;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton
  {
    preset Bounds = <0,435,135,480>;
    preset Bitmap = Application::returnbutton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <13,435>;
    preset Point3 = <118,435>;
    preset Point2 = <118,480>;
    preset Point1 = <13,480>;
    preset OnPress = onAnimateScreen;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton1
  {
    preset Bounds = <135,435,272,480>;
    preset Bitmap = Application::BuyButton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler2
  {
    preset Point4 = <151,435>;
    preset Point3 = <258,435>;
    preset Point2 = <258,480>;
    preset Point1 = <151,480>;
    preset OnPress = onAnimateBuyScreen;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler DrinkNo1TouchHandler1
  {
    preset Point4 = <0,92>;
    preset Point3 = <136,92>;
    preset Point2 = <135,242>;
    preset Point1 = <0,242>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler DrinkNo2TouchHandler1
  {
    preset Point4 = <135,93>;
    preset Point3 = <271,93>;
    preset Point2 = <271,242>;
    preset Point1 = <135,242>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler DrinkNo3TouchHandler1
  {
    preset Point4 = <0,242>;
    preset Point3 = <136,242>;
    preset Point2 = <135,391>;
    preset Point1 = <0,391>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler DrinkNo4TouchHandler2
  {
    preset Point4 = <135,242>;
    preset Point3 = <271,242>;
    preset Point2 = <271,391>;
    preset Point1 = <135,391>;
  }

  // This is a slot method.
  $rect <370,240,570,280>
  slot onAnimateBuyScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect.Enabled = true;
    //this.Bounds = RectEffect.Value;
    RectEffect.Reversed = true;
    BuyScreen.Bounds = RectEffect.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <370,200,570,240>
  object Effects::RectEffect RectEffect
  {
    preset OnAnimate = onAnimateBuyScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // This is a slot method.
  $rect <570,240,770,280>
  slot onAnimateScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect1.Enabled = true;
    this.Bounds = RectEffect1.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <580,200,780,240>
  object Effects::RectEffect RectEffect1
  {
    preset OnAnimate = onAnimateScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::BuyScreen BuyScreen
  {
    preset Bounds = <751,-259,1023,221>;
  }
}

$rect <70,439,270,479>
$output false
class MMenu : Core::Group
{
  $rect <360,290,560,330>
  inherited property Bounds = <0,0,272,480>;

  $rect <360,380,560,420>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <360,340,560,380>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,272,480>;
    preset Bitmap = Application::Menu;
  }

  $rect <510,60,710,100>
  slot onMenu1
  {
    postsignal onShow;
  }

  $rect <510,20,710,60>
  property slot onShow = null;

  $rect <510,140,710,180>
  slot onBuyScreen
  {
    postsignal onShow2;
  }

  $rect <510,100,710,140>
  property slot onShow2 = null;

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <500,-10,730,190>;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton
  {
    preset Bounds = <6,431,119,485>;
    preset Bitmap = Application::returnbutton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler returnTouchHandler
  {
    preset Point4 = <12,443>;
    preset Point3 = <110,443>;
    preset Point2 = <110,480>;
    preset Point1 = <12,480>;
    preset OnPress = onAnimateScreen;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton1
  {
    preset Bounds = <165,437,272,480>;
    preset Bitmap = Application::BuyButton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler buyTouchHandler
  {
    preset Point4 = <165,443>;
    preset Point3 = <272,443>;
    preset Point2 = <272,474>;
    preset Point1 = <165,474>;
    preset OnPress = onAnimateBuyScreen;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler MainNo1TouchHandler
  {
    preset Point4 = <0,106>;
    preset Point3 = <136,106>;
    preset Point2 = <136,240>;
    preset Point1 = <0,240>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler MainNo2TouchHandler
  {
    preset Point4 = <136,106>;
    preset Point3 = <272,106>;
    preset Point2 = <272,240>;
    preset Point1 = <136,240>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler MainNo3TouchHandler
  {
    preset Point4 = <0,240>;
    preset Point3 = <136,240>;
    preset Point2 = <136,396>;
    preset Point1 = <0,396>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler MainNo4TouchHandler
  {
    preset Point4 = <136,240>;
    preset Point3 = <272,240>;
    preset Point2 = <272,411>;
    preset Point1 = <136,411>;
  }

  // This is a slot method.
  $rect <410,240,610,280>
  slot onAnimateBuyScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect.Enabled = true;
    //this.Bounds = RectEffect.Value;
    RectEffect.Reversed = true;
    BuyScreen.Bounds = RectEffect.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <410,200,610,240>
  object Effects::RectEffect RectEffect
  {
    preset OnAnimate = onAnimateBuyScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // This is a slot method.
  $rect <610,240,810,280>
  slot onAnimateScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect1.Enabled = true;
    this.Bounds = RectEffect1.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <610,200,810,240>
  object Effects::RectEffect RectEffect1
  {
    preset OnAnimate = onAnimateScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::BuyScreen BuyScreen
  {
    preset Bounds = <307,-516,579,-36>;
  }
}

$rect <70,490,270,530>
$output false
class DesertMenu : Core::Group
{
  $rect <510,290,710,330>
  inherited property Bounds = <0,0,272,480>;

  $rect <500,400,700,440>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <500,360,700,400>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,272,480>;
    preset Bitmap = Application::Desert;
  }

  $rect <510,60,710,100>
  slot onMenu1
  {
    postsignal onShow;
  }

  $rect <510,20,710,60>
  property slot onShow = null;

  $rect <510,140,710,180>
  slot onBuyScreen
  {
    postsignal onShow2;
  }

  $rect <510,100,710,140>
  property slot onShow2 = null;

  // Tranziti pagini
  note group Note
  {
    attr Bounds = <500,-20,730,180>;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton
  {
    preset Bounds = <0,434,136,480>;
    preset Bitmap = Application::returnbutton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <18,434>;
    preset Point3 = <118,434>;
    preset Point2 = <118,480>;
    preset Point1 = <18,480>;
    preset OnPress = onAnimateScreen;
  }

  $rect <20,20,160,60>
  object Views::Image returnButton1
  {
    preset Bounds = <136,434,272,480>;
    preset Bitmap = Application::BuyButton;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler2
  {
    preset Point4 = <154,434>;
    preset Point3 = <259,434>;
    preset Point2 = <259,480>;
    preset Point1 = <154,480>;
    preset OnPress = onAnimateBuyScreen;
  }

  // This is a slot method.
  $rect <370,240,570,280>
  slot onAnimateBuyScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect.Enabled = true;
    //this.Bounds = RectEffect.Value;
    RectEffect.Reversed = true;
    BuyScreen.Bounds = RectEffect.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <370,200,570,240>
  object Effects::RectEffect RectEffect
  {
    preset OnAnimate = onAnimateBuyScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  // This is a slot method.
  $rect <570,240,770,280>
  slot onAnimateScreen
  {
    // Just move and enlarge all 3 Frame views simultanously.
    // Calculate with an additional offset to arrange the views one below the other.
    RectEffect1.Enabled = true;
    this.Bounds = RectEffect1.Value;

  }

  // This is a move and resize rectangle effect.
  $rect <570,200,770,240>
  object Effects::RectEffect RectEffect1
  {
    preset OnAnimate = onAnimateScreen;
    preset NoOfCycles = 1;
    preset Enabled = false;
    preset Value2 = <0,1000,272,480>;
    preset Value1 = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Application::BuyScreen BuyScreen
  {
    preset Bounds = <554,-452,826,28>;
  }
}

$rect <640,150,840,190>
$output false
class BuyScreenElement : Core::Group
{
  $rect <220,230,420,270>
  inherited property Bounds = <0,0,272,100>;

  $rect <220,310,420,350>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <220,270,420,310>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,144,100>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <144,0,272,100>;
    preset Color = #17086164;
  }

  $rect <210,100,410,140>
  property Resources::Bitmap MyImage;

  $rect <210,140,410,180>
  onset MyImage
  {
    // The value doesn't change - nothing to do.
    if ( pure MyImage == value )
      return;

    // Remember the property's new value.
    pure MyImage = value;

    // TO DO:
    // 
    Image.Bitmap = value;
  }

  $rect <210,180,410,220>
  onget MyImage
  {
    return pure MyImage;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <144,0,272,100>;
    preset Orientation = Views::Orientation.Normal;
    preset String = "Text";
    preset Font = Resources::FontExtraLarge;
  }

  $rect <420,100,620,140>
  property string Price;

  $rect <420,140,620,180>
  onset Price
  {
    // The value doesn't change - nothing to do.
    if ( pure Price == value )
      return;

    // Remember the property's new value.
    pure Price = value;

    // TO DO:
    // 
    Text.String = value;
  }

  $rect <420,180,620,220>
  onget Price
  {
    return pure Price;
  }
}

$rect <919,160,1119,200>
$output false
resource Resources::Bitmap Soup1
{
  attr bitmapfile FileName = .\soup_pui.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,160,1320,200>
$output false
resource Resources::Bitmap Desert1
{
  attr bitmapfile FileName = .\desert_tiramisu.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <919,330,1119,370>
$output false
resource Resources::Bitmap Drinks1
{
  attr bitmapfile FileName = .\drinks_fanta.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,330,1320,370>
$output false
resource Resources::Bitmap Menu1
{
  attr bitmapfile FileName = .\main_ardei.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,490,540,530>
$output false
resource Resources::Bitmap returnbutton
{
  attr bitmapfile FileName = .\return.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <910,500,1110,540>
$output false
resource Resources::Bitmap Bitmap
{
  attr bitmapfile FileName = .\background1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <919,199,1119,239>
$output false
resource Resources::Bitmap Soup2
{
  attr bitmapfile FileName = .\soup_legume.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <919,240,1119,280>
$output false
resource Resources::Bitmap Soup3
{
  attr bitmapfile FileName = .\soup_cartofi.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <919,279,1119,319>
$output false
resource Resources::Bitmap Soup4
{
  attr bitmapfile FileName = .\sout_vacuta.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,199,1320,239>
$output false
resource Resources::Bitmap Desert2
{
  attr bitmapfile FileName = .\desert_clatite.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,240,1320,280>
$output false
resource Resources::Bitmap Desert3
{
  attr bitmapfile FileName = .\desert_cremsnit.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,279,1320,319>
$output false
resource Resources::Bitmap Desert4
{
  attr bitmapfile FileName = .\desert_eclere.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <919,370,1119,410>
$output false
resource Resources::Bitmap Drinks2
{
  attr bitmapfile FileName = .\drinks_coca_cola.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <919,410,1119,450>
$output false
resource Resources::Bitmap Drinks3
{
  attr bitmapfile FileName = .\drinks_pepsi.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <919,450,1119,490>
$output false
resource Resources::Bitmap Drinks4
{
  attr bitmapfile FileName = .\drinks_sprite.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,370,1320,410>
$output false
resource Resources::Bitmap Menu2
{
  attr bitmapfile FileName = .\main_pilaf.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,410,1320,450>
$output false
resource Resources::Bitmap Menu3
{
  attr bitmapfile FileName = .\main_snitel.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1120,450,1320,490>
$output false
resource Resources::Bitmap Menu4
{
  attr bitmapfile FileName = .\main_tochitura.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <340,530,540,570>
$output false
resource Resources::Bitmap confirm
{
  attr bitmapfile FileName = .\confirmation.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}
